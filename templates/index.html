<!doctype html>
<html lang="en" data-bs-theme="dark">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>Lyrics Downloader</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <style>
        [data-tooltip] {
            position: relative;
        }

        [data-tooltip]:hover::after {
            display: block;
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            content: attr(data-tooltip);
            background: #000;
            padding: .8em 1em;
            border-radius: 12px;
            top: 2.5em;
            width: max-content;
            z-index: 10000000;
        }

        [data-tooltip].tooltip-display::after {
            display: block;
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            content: attr(data-tooltip);
            background: #000;
            padding: .8em 1em;
            border-radius: 12px;
            top: 2.5em;
            width: max-content;
            z-index: 10000000;
        }
    </style>
</head>
<body>
    <div id="app" class="container my-5">
        <h1>Download Lyrics for Music Files</h1>
        <form @submit.prevent="fetchFiles">
            <div class="form-group">
                <label for="directory">Directory Path</label>
                <input type="text" class="form-control" id="directory" v-model="directory" required>
            </div>
            <span :data-tooltip="state === AppState.Downloading ? 'Lyrics download is currently running.' : null">
                <button type="submit" class="btn btn-primary mt-2" :disabled="state === AppState.Downloading">Fetch Files</button>
            </span>
        </form>
        <div v-if="error" class="alert alert-danger mt-3">
            [[ error ]] <!-- TODO -->
        </div>

        <div v-if="files.length" class="mt-4">
            <span class="h4">Files ([[ files.length ]])</span>
            <div v-for="(file, index) in files" :key="index" class="card my-3" :style="getBackgroundColor(states[file])">
                <div class="card-body">
                    <span class="text-secondary">[[ index+1 ]]. </span>
                    [[ file ]] 
                    <span class="float-end">
                        &nbsp;<span v-if="state !== AppState.WaitingForDirectory || state !== AppState.WaitingForDownload">[[ states[file] ]]</span>
                        &nbsp;<button v-if="state === AppState.WaitingForDownload" type="button" class="btn-close float-end" aria-label="remove file" @click="removeFile(index)"></button>
                    </span>
                </div>
            </div>
            <button v-if="state === AppState.WaitingForDownload" @click="downloadLyrics" class="btn btn-success mt-2">Download Lyrics</button>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/vue@2"></script>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <script>
        const AppState = {
            Init: 'Init',
            WaitingForDirectory: 'WaitingForDirectory',
            WaitingForDownload: 'WaitingForDownload',
            Downloading: 'Downloading',
            Done: 'Done',
        };

        new Vue({
            el: '#app',
            delimiters: ['[[', ']]'],
            data: {
                directory: '/var/home/nalsai/Documents/GitHub/syncedlyrics-ui/_/',
                files: [],
                states: {},
                error: '',
                interval: null,
                state: AppState.Init
            },
            methods: {
                getBackgroundColor(state) {
                    if (state === 'Pending') {
                        return { backgroundColor: '#000' };
                    } else if (state === 'Downloaded') {
                        return { backgroundColor: '#040' };
                    } else if (state === 'Lyrics already present') {
                        return { backgroundColor: '#044' };
                    } else if (state === 'No lyrics found') {
                        return { backgroundColor: '#004' };
                    } else if (state.includes('Error')) {
                        return { backgroundColor: '#400' };
                    }
                    return {};
                },
                removeFile(index) {
                    this.$delete(this.files, index);
                },
                async fetchFiles() {
                    if (this.state === AppState.Downloading) {
                        console.error('Not WaitingForDirectory, state:', this.state);
                        return;
                    }
                    try {
                        this.error = '';
                        const response = await axios.post('/files', { directory: this.directory });
                        this.files = response.data.files;
                        this.states = response.data.states;
                        this.state = AppState.WaitingForDownload;
                    } catch (error) {
                        this.error = error.response.data.error || 'An error occurred';
                    }
                },
                async downloadLyrics() {
                    if (this.state !== AppState.WaitingForDownload) {
                        console.error('Not WaitingForDownload, state:', this.state);
                        return;
                    }
                    try {
                        this.state = AppState.Downloading;
                        const response = await axios.post('/download_lyrics', { files: this.files });
                        //alert(response.data.status);
                        console.log(response.data.status);
                        this.startPolling();
                    } catch (error) {
                        alert(error.response.data.error || 'An error occurred');
                    }
                },
                startPolling() {
                    if (this.interval) {
                        clearInterval(this.interval);
                    }
                    this.interval = setInterval(this.updateStates, 2000);
                },
                async updateStates() {
                    try {
                        const response = await axios.get('/states');
                        this.states = response.data;
                        this.$forceUpdate();
                        // it no state is pending, stop polling
                        // TODO: if lyrics should be redownloaded, should also allowed "Lyrics already present"
                        if (!Object.values(this.states).some(state => state === "Pending")) {
                            clearInterval(this.interval);
                            this.state = AppState.Done;
                        }
                    } catch (error) {
                        console.error('Error fetching states:', error);
                    }
                },
                async getState() {
                    try {
                        const response = await axios.get('/states');
                        this.states = response.data;
                        this.files = Object.keys(this.states);

                        this.$forceUpdate();

                        if ({{ downloading }}) { // the current state gets inserted from the backend
                            this.state = AppState.Downloading;
                            this.startPolling();
                        }
                        
                        // it no state is pending, stop polling
                        // TODO: if lyrics should be redownloaded, should also allowed "Lyrics already present"
                        /*if (!Object.values(this.states).some(state => state === "Pending")) {
                            clearInterval(this.interval);
                            this.state = AppState.Done;
                        }*/
                    } catch (error) {
                        console.error('Error initial state(s):', error);
                    }
                }
            },
            beforeMount() {
                this.getState()
            },
            beforeDestroy() {
                if (this.interval) {
                    clearInterval(this.interval);
                }
            }
        });
    </script>
</body>

</html>